 Три состояния

Commited — файл сохранён в базе данных.

Modified — файл изменился но ещё не был зафиксирован.

Staged — изменённый файл отмеченный для включения в следующий коммит.
Настройка Git

Перед использованием git его нужно немного подстроить в качестве обязательных настроек необходимо указать user.name и user.email (изменить эти данные в конкретном репозитории уже не возможно). Без этого репозиторий не может существовать. Кроме этого желательно указать core.editor — это редактор, который будет открываться при каждой фиксации изменений.

$ git config --global user.name "MyName"

$ git config --global user.email my@email.com

$ git config --list Проверка настроек.

$ git config user.name Проверка конкретного ключа.
Помощь Git

$ git help <verb>

$ git <verb> --help

$ man git-<verb>
Создание репозитория Git

$ git init Создаёт основу git репозитория — директорию .git.

$ git clone https://github.com/my/repo клонирование репозитория.

$ git clone https://github.com/my/repo mydir клонировать репозиторий в папку mydir.
Добавить под контроль существующие файлы

    Инициализируем репозиторий в текущей папке $ git init

    Представимся, иначе ничего не получится.

        $ git config --global user.name "MyName"

        $ git config --global user.email my@email.com

     git remote add origin git@github.com:username/repo.git
     
     
     

!@#  .git  .gitignore  LICENSE  README.md





    Добавляем файлы в индекс и они переходят в состояние staged
    $ git add *

    Осуществляем первый коммит и файлы переходят в состояние commited
    $ git commit -m 'Проект в первоначальном состоянии'

Определение состояния файлов

Основной инструмент для определения состояния файлов – это команда git status.
Вводим эту команду в терминале и видим все изменения которые произошли с репозиторием.


В определенном репозитории Git конфигурации хранятся в скрытой папке .git/ в файле конфигурации Git с именем config.

# your_project/.git/config

$ git status

$ git status -s Сокращённый вывод статуса.

$ git status --short
Отслеживание новых файлов

Для начала отслеживания (добавления под версионный контроль / добавления контента в следующий коммит) используется команда git add

$ git add filename

$ git add pathTo/filename

$ git add pathTo добавит все файлы из директории pathTo (рекурсивно).

Нужно помнить что git add индексирует (добавляет под версионный контроль /добавляет контент в следующий коммит) точно в том состоянии, в котором он находится, когда выполняется команда. Если файл изменился после этого то он будет сразу и staged и modified. Другими словами делаем git add непосредственно перед git commit.
Игнорирование файлов в git

Создаём файл .gitignore в котором перечисляем на каждой строке шаблоны соответствующих файлов.
Примеры шаблонов в файле .gitignore

*.[oa] игнорировать все файлы заканчивающиеся на .o или на .a.

*~ игнорировать все файлы заканчивающиеся на ~.

dir/ игнорировать все файлы в директории dir.

*.a игнорировать все файлы заканчивающиеся на .a.

!lib.a кроме файла lib.a.

/file игнорировать файл file но не pathTo/file.

pathTo/*.txt игнорировать все txt файлы в папке pathTo.

pathTo/**/*.txt игнорировать все txt файлы в папке pathTo и всех подпапках.
Правила для файла .gitignore

Игнорируются пустые строки, строки начинающиеся с #.

    Можно использовать стандартные glob шаблоны (упрощенные регулярные выр-я)

        * 0 или более символов

        [xyz] любой символ из указанных

        ? один символ

        [0-9] любой символ из интервала

        a/**/z эквивалентно a/z, a/b/z, a/b/c/z и т.д.

    Можно начинать шаблон с символа / чтобы избежать рекурсии

    Можно заканчивать шаблон символом / для указания каталога

    Можно инвертировать шаблон с помощью первого символа !

Просмотр изменений

Команда git diff отвечает на вопрос, что мы изменили но ещё не проиндексировали и что мы проиндексировали и собираемся закоммитить. Она показывает непосредственно добавленные и удалённые строки (patch). Выйти из просмотра с помощью клавиши q.

$ git diff сравнивает содержимое каталога с содержимым индекса.

$ git diff --staged (--staged и --cached синонимы) сравнивает индексированные изменения с последним коммитом.

$ git difftool просмотр изменений с помощью программ.

$ git difftool --tool-help посмотреть какие программы сравнения уже установлены.
Фиксация изменений

$ git commit простейший способ зафиксировать изменения. При нём в комментарий попадёт закомментированный результат работы программы.

$ git commit -v В комментарий попадёт так же разница (diff) изменений.

$ git commit -m „Мой комментарий“ В комментарии мой комментарий.

Команда commit выводит на какую ветку вы её выполнили (master), контрольную сумму, сколько файлов изменено.
Игнорирование индексации

Файл переходит сразу из состояния modified в состояние commited минуя staged. Другими словами не нужно производить git add.

$ git commit -a -m 'Добавлен новый коммит'
Удаление файлов

Команда git rm удалит отслеживаемый файл из индекса так, что после следующего коммита мы его так же не увидим как неотслеживаемый. В команду git rm можно передавать файлы, каталоги или glob-шаблоны (но нужно экранировать *).

$ git rm filename Удалит файл из индекса и удалит вообще после коммита.

$ git rm -f filename -f необходим если файл изменён и проиндексирован.

$ git rm --cached filename удалить из репозитория но оставить в файловой системе. Полезно когда файл забыли добавить в .gitignore.

$ git rm log/\*.log Удалить все файлы имеющие расширение .log лежащие в log/.

$ git rm \*~ Удалить все файлы заканчивающиеся на ~.
Переименование файлов

$ git remote add origin <url> Добавить репозиторий

$ git mv fileNameBefore fileNameAfter Переименование файла

Равносильно

$ mv fileNameBefore fileNameAfter

$ git rm fileNameBefore

$ git add fileNameAfter
Просмотр истории коммитов

$ git log перечисляет коммиты в обратном хронологическому порядке (последние коммиты вверху).

$ git log -p -p покажет разницу, внесённую в каждый коммит.

$ git log -4 -number покажет только часть коммитов (в данном случае 4 коммита).

$ git log --stat Покажет сокращённую статистику изменений каждого коммита.

$ git log --pretty=oneline --pretty меняет формат вывода. Можно использовать oneline (коммиты в одну строку), short, full, fuller.

$ git log --pretty=format:"%h - %an, %ar : %s" format позволяет создать свой формат вывода информации. Это нужно если нужен автоматический анализ.

%H
	

Хеш коммита

%h
	

Сокращенный хеш коммита

%T
	

Хеш дерева

%t
	

Сокращенный хеш дерева

%P
	

Хеш родителей

%p
	

Сокращенный хеш родителей

%an
	

Имя автора (автор файла)

%ae
	

Электронная почта автора

%ad
	

Дата автора (формат даты можно задать опцией --date=option)

%ar
	

Относительная дата автора

%cn
	

Имя коммитера (автор изменений)

%ce
	

Электронная почта коммитера

%cd
	

Дата коммитера

%cr
	

Относительная дата коммитера

%s
	

Содержание


 
Распространённые опции команды git log

Описание некоторых наиболее распространённых опций для форматирования вывода с помощью команды git log

-p
	

Показывает патч для каждого коммита.

--stat
	

Показывает статистику измененных файлов для каждого коммита.

--shortstat
	

Отображает строку с количеством изменений для команды --stat.

--name-only
	

Показывает список измененных файлов после информации о коммите.

--name-status
	

Показывает список файлов, которые добавлены/изменены/удалены.

--abbrev-commit
	

Показывает несколько символов хеша вместо 40

--relative-date
	

Отображает дату в относительном формате вместо стандартного

--graph
	

Отражает граф с ветвлением и историей слияний

--pretty
	

Коммиты в альтернативном варианте
Ограничение вывода

Ограничение вывода команды git log возможно с помощью нескольких опций. Первая это просто количество указать -n. Кроме этого можно использовать ограничение вывода по времени. Это опции --since --until --after --before

$ git log --since=2.weeks Возможно 2016-09-17, 2 years, 1 day, 3 minutes ago.

$ git log --author=Name Можно по ограничить по автору.

$ git log --committer=Name Ограничить по коммитеру.

$ git log --grep=KeyWord Можно по ключевому слову в сообщении.

$ git log --grep=KeyWord --author=Name --all-matc Пример с двумя фильтрами.

$ git log --SsomeString Опция -S принимает строку и показывает только те коммиты, в которых изменение в коде повлекло за собой добавление или удаление этой строки.

Ниже пример комбинирования опций в отображении где мы хотим увидеть, в каких коммитах произошли изменения в тестовых файлах в истории исходного кода Git, автором которых был пользователь с именем gitster и которые не были слияниями в октябре 2008 года.

$ git log --pretty="%h - %s" --author=gitster --since="2008-10-01" --before="2008-11-01" --no-merges —t
Отмены в Git

Когда может понадобится отмена:

    Дописать в коммит (переформировать коммит).

    Выписать из индекса (снять состояние staged).

    Отмена изменений файла в состоянии modified.

Дописать файл в коммит (переформировать коммит)

Рано сделали коммит. Забыли добавить файл или комментарий. Все файлы в состоянии staged перейдут в состояние commited

$ git commit --amend Запуститься редактор комментария к коммиту

$ git commit -m 'initial commit'

$ git add forgotten_file

$ git commit --amend
Выписать из индекса (снять состояние staged)

Данная команда без опций не опасна.

$ git reset HEAD <file>
Отмена изменений файла в состоянии modified

Данная команда опасна и её отмена не предусмотрена.

$ git checkout -- <file>
Ветвление в Git

Ветвление в Git это большой, очень нужный и интересный раздел полный нюансов, по этому для его освещения стоит написать отдельное литературное произведение. Но для создания представления о сути ветвления можно представить следующую ситуацию. Программист работает с определённым функционалом, и работает всегда в параллельной ветке. Назовём основную ветку main а параллельную develop. В случае если он всё протестировал и уверен что программа работает как надо то он сливает ветку develop c main. А уж ветку develop ветвит как хочет, особенно если он трудится над ней с друзьями.

$git branch показать ветки.

$ git branch [branch-name] Создать ветку [branch-name].

$ git branch -d [branch-name] Удалить ветку [branch-name].

$ git branch -m [branch-name] [new-name] Переименовать ветку .

$ git checkout [branch-name] Перейти к ветке [branch-name].

$ git merge [branch-name] слияние ветки [branch-name] с текущей.
Работа с удалёнными репозиториями

Под контролем могут быть несколько репозиториев. Нужно уметь добавлять/удалять репозитории, а так же управлять различными ветками, делать их отслеживаемыми или нет.

$ git remote просмотр репозиториев

$ git remote -v просмотр с адресом

$ git remote add repo https://github.com/habName/repoName добавлен репозиторий repo.

Теперь вместо указания полного пути вы можете использовать repo. Например, если вы хотите получить изменения, которые есть у repoName, но нету у вас, вы можете выполнить команду git fetch repo. Ветка myBranch из репозитория repoName теперь доступна под именем repo/myBranch.

$ git fetch [remote-name] получить изменения из репозитория remote-name.

$ git fetch [remote-name] [branch-name] получить изменения конкретной ветки из репозитория remote-name. Если не писать [branch-name] то будет получена только одна активная в настоящий момент ветка.

 git push [remote-name] [branch-name] записать изменения в репозиторий.

$ git remote show [remote-name] посмотреть информацию о репозитории.

$ git remote rename nam1 nam2 переименовать, перенести репозиторий.

$ git remote rm nam1 удалить репозиторий.
Метки в Git

Метки позволяют выделять определённые моменты в истории.

$ git tag просмотр меток

$ git tag -l „v.1.*“ поиск меток по шаблону
Создание меток

    Легковесные метки — это указатель на определённый коммит.

    Аннотированная метка — храниться в базе данных git как объект. (контрольная сумма, комментарий, имя автора метки, дата, email,

$ git tag -a [tag-name] -m „комментарий“ создание аннотированной метки.

$ git show [tag-name] смотрим данные метки вместе с коммитом.

$ git tag [tag-name] создание легковесной метки

Метки можно создавать и позже, нужно только знать к какому коммиту. Для этого нужно указать контрольную сумму или её часть в конце команды создания метки.
$ git tag -a [tag-name] [hash-or-pice]

Метками можно обмениваться
$git push origin [имя метки]

Переход на метку в действительности не возможен. А что тогда возможно? Создание новой ветки с определённой меткой.

$ git checkout -b [branch-name] [tag-name]
Псевдонимы команд в Git

Есть одна маленькая хитрость, которая поможет сделать использование Git проще - это псевдонимы (alias). Они позволяют печатать псевдоним вместо команды. Настраиваются с помощью git config --global alias.[alter] [command]

$ git config --global alias.co checkout checkout теперь == co
$ git config --global alias.br branch branch == br
$ git config --global alias.ci commit
$ git config --global alias.st status
$ git config -- alias.unstage 'reset HEAD –' популярное сокращение.
$ git config --global alias.last 'log -1 HEAD' популярное сокращение.
$ git config --global alias.visual "!gitk" запустить внешнюю утилиту gitk
$ python3 setup.py install 

<!--next 300 meters -->
$ ctrl + alt + f1
$ ctrl + alt + f7 
<!-- please do not try harakiri -->
server {
   listen 192.168.0.120:80;

   server_name url-routing.efim360.ru;
   root /var/www/url-routing.efim360.ru;

   index index.html index.htm;

   location / {
      proxy_pass http://192.168.0.120:8008;
      proxy_set_header Host $host;
   }
}
